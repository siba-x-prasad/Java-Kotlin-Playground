# SEALED CLASS- Sealed classes and interfaces represent restricted class hierarchies that provide more control over inheritance.- Application have lots of states - fail, success, progress- It works in MVVM, MVI, MVP- Sealed classes are used for representing restricted class hierarchies, when a value can have one of the types from a limited set, but can not have any other type. They are, i a sense, an extension of enum classes : the set of values for an enum type is also restricted, but each enum constant exists only as single instance, whereas a subclass of a sealed class can have multiple instances which can contain state.- There are the properties   - Restricted hierarchies   - Set   - Types   - Contain Values- Basic example```sealed class Result {    class Success(val items: List<String>) : Result()    class Failure(val error: Throwable) : Result()}```  ```when (result) {    is Result.Success -> showItems(result.items)    is Result.Failure -> result.error.printStackTrace()}```- In above when statement don't have any else clause because compiler knows that it only have 2 values- If you add another class inside Result then when clause will show error.```sealed class Result {    class Success(val items: List<String>) : Result()    class Failure(val error: Throwable) : Result()    class Cancelled(val msg: String) : Result()}```  ```when(result){    is Result.Success -> showItems(result.items)    is Result.Failure -> result.error.printStackTrace()    is Result.Cancelled -> println("Cancelled")}```## Example```sealed class Result {    data class Success(val data: Any) : Result()    data class Error(val message: String) : Result()    object Loading : Result()}``````fun processResult(result: Result) {    when (result) {        is Result.Success -> {            println("Success: ${result.data}")        }        is Result.Error -> {            println("Error: ${result.message}")        }        Result.Loading -> {            println("Loading...")        }    }}val successResult = Result.Success("Data")val errorResult = Result.Error("Something went wrong")val loadingResult = Result.LoadingprocessResult(successResult) // Output: Success: DataprocessResult(errorResult) // Output: Error: Something went wrongprocessResult(loadingResult) // Output: Loading...```## Use Enum Classes When:- You have a fixed set of options that represent distinct values.- Each option doesn't require any additional properties or behaviors.- You need type-safety and exhaustive handling of the options.## Use Sealed Classes When:- You want to define a closed type hierarchy with a finite number of subclasses.- Each subclass can have its own properties and behaviors.- You need exhaustive handling of all possible subclasses.     